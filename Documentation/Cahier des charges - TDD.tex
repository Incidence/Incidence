\documentclass[a4paper]{article}
\usepackage[utf8x]{inputenc}  % si utf8
\usepackage{graphicx}

\pagestyle{plain}

\title{\textbf{Technical Design Document}\\- \Huge{Incidence} -}
\author{\emph{CHAMBONNET Kevin}\\\emph{GAUTHIER Silvère}\\\emph{MARTINEZ Thierry}\\\emph{MOKHRETAR Amin}}
\date{\today}

\newcommand{\alinea}{\hspace*{0.5cm}}

\begin{document}
  \maketitle
  \newpage
  \tableofcontents

% Liens utiles : 
% https://www.digipen.edu/fileadmin/website_data/gallery/game_websites/NarbacularDrop/documents/narbacular_drop_technical_design_document.pdf

  \newpage
  \part{Organisation}
    \section{Gestion du projet}
      \subsection{Gestion de l'équipe}
        \alinea Tous les membres se connaissant et étant supposés être capable de travailler en équipe, nous n'avons fait aucune élection de chef de projet.\\
        \alinea Nous avons opté pour travailler de manière collégiale, et ainsi garder une cohésion de groupe sans pour autant avoir de hiérarchie instaurée au sein du groupe, qui pourrait au contraire déservir la réalisation de nos objectifs.\\
        \alinea Chaque membre a donc autant de pouvoir que les autres, et peut donc participer activement au projet, autant lors de la conception que du développement. Toutes les décisions seront prises suivant la majorité lors de votes.\\\\
        \alinea Pour ce qui est des réunions de projets, nous avons convenu avec notre tuteur d'une réunion, allant d'environ trente minutes à une heure, toutes les une à deux semaines, afin de mettre au point l'avancement du projet. En parallèle, tous les membres de notre équipe se retrouvent une fois par semaine afin de discuter des points clés effectués ou à venir, donner lieu aux votes pour les prises de décisions, ou encore, lors de la phase de développement, travailler en collaboration afin d'optimiser notre travail.\\\\
        \alinea Au niveau du travail collaboratif, nous avons mis en place un dépôt sur github, contenant tant la documentation telle que ce rapport que les sources de notre jeu. Par ailleurs, nous mettrons sur ce dépôt uniquement les fichiers sources, les images et les sons, mais en aucun cas les fichiers temporaires ou les exécutables. Un fichier "makefile" sera disponible pour quiconque voudrait compiler le programme chez lui. Les seuls fichiers binaires disponibles seront les PDF de la documentation, pour un soucis de facilité d'accès.

      \subsection{Découpage en tâches}
        \alinea Afin de préparer le développement du jeu, il était nécessaire de séparer les fonctionnalités les unes des autres. Nous avons abouti à ce diagramme, qui résume notre choix de découpage :
        \begin{center}
          \includegraphics[scale=0.5]{DiagrammeDecoupageProjet.png}
        \end{center}

      \subsection{Assignation}
        \alinea Le projet étant maintenant découpé en un certain nombre de modules, il ne restait plus qu'à assigner chaque tâche à un ou plusieurs membres de l'équipe. Nous nous sommes organisés comme ceci :
        \begin{itemize}
          \item \textbf{Scripts de l'IA :} MARTINEZ Thierry, MOKHRETAR Amin.
          \item \textbf{Moteur :}
          \begin{itemize}
            \item \textbf{Gestion de la carte :} GAUTHIER Silvère.
            \item \textbf{Gestion des entités :} CHAMBONNET Kevin.
          \end{itemize}
          \item \textbf{Interface :} Tous les membres.
        \end{itemize}
        \alinea Bien entendu, cette répartition n'est pas totalement fixée, elle concerne en réalité l'affectation de responsables de parties, qui seront en charge de celle-ci mais pourront évidemment faire appel aux autres membres pour trouver une solution à un problème par exemple.\\
        \alinea Le détail complet des tâches et assignations se situe dans la section Gestion du temps, page \pageref{GestionTps}.

      \subsection{Gestion du temps}
        \label{GestionTps}
        \alinea Afin de clarifier notre gestion du temps, un diagramme Gantt est disponible dans la documentation de notre projet, et sera mis à jour en fonction de l'avancée du projet.\\
        \alinea Voici tout de même une première estimation du temps nécessaire :
        \begin{center}
          %\includegraphics[scale=0.5]{DiagrammeGantt.png}
        \end{center}

    \section{Choix technologiques}
      \subsection{Langages de programmation}
        \alinea Pour des besoins de performances, nous avons comparé différents langages. Pour réduire le temps de recherche et de comparaison, nous nous sommes appuyé sur des tests déjà effectués par d'autre.\\
        \alinea Voici des tests de performances concernant un large panel de langages, comparés ici dans quatre contextes différents :\\
        \begin{center}
          \includegraphics[scale=0.5]{AnalyseLangage1.png}
          \includegraphics[scale=0.5]{AnalyseLangage2.png} 
        \end{center}
        \alinea Nous pouvons observer que globalement, le langage le plus rapide est ici C++. L'utilisation de ce langage étant très fréquente dans les jeux vidéos, de part sa réputation d'un des langages les plus performants, et tous les membres de notre équipe sachant l'utiliser, nous avons fait le choix de programmer le moteur du jeu en C++.\\
        \alinea Afin d'optimiser encore la rapidité du moteur, nous avons cherché à associer son coeur écrit en C++ avec un langage de scripting qui permettra de mettre en place les différentes actions du jeu.\\ D'après les graphiques ci-dessus, nous avons opté pour le langage LUA, performant et facile d'utilisation (syntaxe proche du C++). En effet, même si Python est très prisé et offre beaucoup plus de possibilités que LUA, nous l'avons estimé bien trop lourd pour l'utilisation que nous allons en faire.\\
        \alinea Les deux langages C++ et LUA sont souvent associés dans les jeux vidéos, notre choix suit donc la tendance, ce qui nous offre une certaine assurance.

      \subsection{Bibliothèques}
        \alinea Pour la gestion graphique des tuiles composant la carte et des différentes entités, nous avons cherché une bibliothèque relativement simple d'utilisation mais surtout performante afin de garder la fluidité gagnée avec le choix des langages de programmation.\\
        \alinea Connaissant la bibliothèque OpenGL, qui est bas niveau et performante dans les affichages deux et trois dimensions, nous nous sommes tournés vers deux bibliothèques utilisant OpenGL : SDL et SFML.\\
        \alinea D'après plusieurs sites web et forums, les dernières versions (respectivement 2.0 et 2.1) de ces deux bibliothèques se valent en terme de performance.\\
        \alinea En confrontant nos préférances personnelles quant au choix de l'une ou l'autre, nous nous sommes finalement mis d'accord pour utiliser la bibliothèque graphique SFML 2.1, qui paraît plus simple d'utilisation que la SDL. De plus, elle permet une gestion aisée des fichiers son, ce qui sera un plus pour la finalité de notre jeu.
		
		
\newpage
  \part{Code Overview}
    \section{Format des Fichiers}
		% un petit blabla sur les fichier en generale CPP/HPP/LUA
		% Images en PNG et sons en WAV
		\subsection{Animation} % On peu chager la police ? FAire un truc genre on voit que c'est un fichier source ?
			Chemin/vers/image.png size_x_sprite size_y_sprite play?(1/0) loop?(1/0)\\
			+Frame position_x position_y temps_affichage\\
			+Frame position_x position_y temps_affichage\\
			+Frame position_x position_y temps_affichage\\
		\subsection{Tileset}
		\subsection{Carte}
		\subsection{Sauvegarde}
    \section{Commentaires}
		%Pareil qu'en dessous.
    \section{Convention de Nommage}
		%Faudra se mettre d'accord sur une, et la suivre
    \section{Source Controle} % Traduire ?
		%Blabla on utilise GIT
		
\newpage
  \part{Developpement} %Il y a meilleurs comme nom 
	\section{Le Moteur}
		Le moteur du jeu est très basique et sert surtout à la gestion plus simplifié des différents états du jeu ainsi que de toutes les ressources.
		\subsection{Etat}
			Le Moteur contient un gestionnaire d'état qui permet de controler et d'appeler le dernier état du jeu. Une classe abstraite Etat est la classe mère de tout les états, chaque etat ainsi crée aura une méthode de mise à jour, d'affichage et de gestion des différentes actions clavier/souris du joueur.
		\subsection{Animation}
			Une classe Animation a été crée pour facilité la création et le controle de toutes les animations du jeu. Toutes les animations peuvent etre modifié grace aux fichiers d'initialisation de chacunes d'elles.
		\subsection{Gestion des Ressources}
			Une classe de gestionnaire de ressources permet de gérer toutes les ressources du jeu pour éviter de charger en double ou plus certaines ressources. Ce gestionnaire gère toutes les textures, images et sons.
			
			
    \section{Les Entités}
		Les entités constitueront tout ce qu'il y a de mobile dans le monde : les Citoyens et les différents Animaux.\\
		Chaque entité possedera des methodes communes utilisé dans les différents scripts de leur IA :
		\begin{itemize}
            \item \textbf{Connaitre sa position sur la carte : } La position sera donné en valeur entière correspondant à la case sur laquelle l'entité est presente.
            \item \textbf{Se déplacer vers une direction donné : } L'entité se déplacera en ligne droite dans cette direction. Si des obstacles se trouvent sur le chemin, elle essayera, si possible, de les contourner.
            \item \textbf{Connaitre les entités alentours : } Recupère une liste d'entités présentes dans le champs de vision de l'entité appelant la méthode.
            \item \textbf{Connaitre les cases alentours : } Recupère une listes de booléen correspondant aux differentes cases présentes dans le champs de vision, avec pour valeur TRUE si la case est franchissable, FALSE sinon.
            \item \textbf{}
            \item \textbf{}
        \end{itemize}
		De plus, toutes les entités auront une methode de mise à jour, qui appellera le script en cours, et une d'affichage, pour l'afficher sur la carte.
		
		Chaque entité possedera aussi une liste d'attribut modifiable par les différentes méthodes : 
		\begin{itemize}
            \item \textbf{Sa position sur la carte : } En pixel et non en case.
            \item \textbf{Son activité : } C'est à dire, le script en cours.
            \item \textbf{Son Animation en cours : } Le visuel de l'entité.
            \item \textbf{}
		\end{itemize}
		
		\subsection{Les citoyens}
			Les Citoyens sont les entités que le joueur devra garder en vie et c'est elles qui auront un impact direct sur l'environnement.
			
			Pour cela, ils possedent des methodes supplementaires :
			\begin{itemize}
				\item \textbf{Connaitre les positions d'un type de case alentours : } Retourne une liste de position correspondant aux positions d'un type de case, passé en parametre, dans le champs de vision du citoyen.
				\item \textbf{Interagir avec une case : } Le citoyen interagit avec la case passé en parametre. Ex.: Pour un arbre, il le coupera.
				\item \textbf{}
			\end{itemize}
			
			Chacun des citoyens aura un metier assigné durant la nuit, et c'est ce metier qui definira le groupe de script que le citoyen suivra pour effectuer ses actions. Ce metier ajoute donc aussi de nouveaux attributs :
			\begin{itemize}
				\item \textbf{Le nom du metier : } Pour facilement connaitre le metier mais aussi la ressource associé au metier et surtout le groupe de script à appeler.
				\item \textbf{La quantité de ressource porté : } Chaque entité pouvant porter qu'un seul type de ressources, cette quantité est associé à la ressource lié au metier. Ex.: Bois pour Bucheron.
				\item \textbf{}
			\end{itemize}
		
		\subsection{Liste des scripts}
			
    \section{La Carte}
		\subsection{Les Tuiles}
		\subsection{Le Tileset}
			
\newpage
  \part{Milestones}
	12 Mars 2013 : Gestion de la carte et des entités terminé + ajout des entités sur la carte + ajout des scripts aux entités
	19 Mars 2013 : Finalisation des scripts et des entités
	10 Avril 2013 : Fin de la premiere version :D

\end{document}
