!<arch>
Carte.cpp/      1394015725  1000  1000  100644  3530      `
Carte::Carte(){
	//TODO
}

Carte::Carte(TileSet tileset){ m_tileset = tileset; }

Carte::Carte(TileSet tileset, sf::Vector2u dimensions){

	m_tileset = tileset;
	m_dimensions = dimensions;

}

Carte::~Carte(){
	//TODO
}

sf::Vector2u Carte::getDimensions(){ return m_dimensions; }

void Carte::setDimensions(sf::Vector2u dimensions){ dimensions = m_dimensions; }

void Carte::setTileSet(TileSet tileset){ m_tileset = tileset; }

Case Carte::getSol(sf::Vector2f position){

	Vector2u tilesize = m_tileset.getTileSize();
	int ligne = (int)(position[1]/tilesize[1]);
	int colonne = (int)(position[0]/tilesize[0]);

	return Case[ligne*m_dimensions[0]+colonne];

}

Case Carte::getObjet(sf::Vector2f position){

	Vector2u tilesize = m_tileset.getTileSize();
	int ligne = (int)(position[1]/tilesize[1]);
	int colonne = (int)(position[0]/tilesize[0]);

	return Case[m_dimensions[0]*m_dimensions[1] + ligne*m_dimensions[0]+colonne];

}

Case Carte::getEntite(sf::Vector2f position){

	Vector2u tilesize = m_tileset.getTileSize();
	int ligne = (int)(position[1]/tilesize[1]);
	int colonne = (int)(position[0]/tilesize[0]);

	return Case[2*m_dimensions[0]*m_dimensions[1] + ligne*m_dimensions[0]+colonne];

}

void Carte::ajouterObjet(int type, sf::Vector2f position){

	Vector2u tilesize = m_tileset.getTileSize();
	int ligne = (int)(position[1]/tilesize[1]);
	int colonne = (int)(position[0]/tilesize[0]);

	Case[m_dimensions[0]*m_dimensions[1] + ligne*m_dimensions[0]+colonne].setType(type);

}

void Carte::supprimerObjet(sf::Vector2f position){

	ajouterObjet(AUCUN, position);

}

void Carte::changerSol(int type, sf::Vector2f position){

	Vector2u tilesize = m_tileset.getTileSize();
	int ligne = (int)(position[1]/tilesize[1]);
	int colonne = (int)(position[0]/tilesize[0]);

	Case[ligne*m_dimensions[0]+colonne].setType(type);

}

void Carte::ajouterEntite(int type, sf::Vector2f position){

	Vector2u tilesize = m_tileset.getTileSize();
	int ligne = (int)(position[1]/tilesize[1]);
	int colonne = (int)(position[0]/tilesize[0]);

	Case[2*m_dimensions[0]*m_dimensions[1] + ligne*m_dimensions[0]+colonne].setType(type);

}

void Carte::supprimerEntite(sf::Vector2f position){

	ajouterEntite(AUCUN, position);

}

void Carte::loadSol(const int* sol){
	//TODO
}

void Carte::loadObjets(const int* objets){
	//TODO
}

void Carte::loadEntites(const int* entites){
	//TODO
}

bool Carte::charger(string path){
	//TODO
}

bool Carte::sauver(string path){
	//TODO
}

void Carte::draw(sf::RenderTarget& target, sf::RenderStates states) const{

	drawSol(target, states);
	drawObjets(target, states);
	drawEntites(target, states);

}

void Carte::drawSol(sf::RenderTarget& target, sf::RenderStates states){

	target.draw(m_sol);

}

void Carte::drawObjets(sf::RenderTarget& target, sf::RenderStates states){

	target.draw(m_objets);

}

/* Cette fonction dessine les entités et si besoin les parties hautes 
 * des arbres qui devraient cacher les entités correspondantes.
 */
void Carte::drawEntites(sf::RenderTarget& target, sf::RenderStates states){

	target.draw(m_entites);

	int longueur = m_dimensions[0], hauteur = m_dimensions[1];

	for(int i(longueur*largeur) ; i<2*longueur*largeur ; ++i) {
		if(m_cases[i + longueur*largeur] != AUCUN) {
			if(m_cases[i] == ARBRE_HAUT || m_cases[i] == ARBRE_FRUITIER_HAUT) {
				//TODO : target.draw(cases[i]) avec VertexArray
			}
		}
	}

}
